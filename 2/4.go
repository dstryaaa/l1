package main

import "fmt"

func main() {
	ch1 := make(chan int)    // создание не буферизированного канала
	go func() { ch1 <- 1 }() // отправка значения в канал
	val := <-ch1             // получение значения из канала
	fmt.Println(val)
	// В данном примере наш канал ch не является буферизированным.
	// Мы отправляем значение 1 в канал, а затем получаем его значение.
	ch2 := make(chan int, 2) // создание буферизированного канала размера 2
	go func() { ch2 <- 2 }() // отправка значения в канал
	go func() { ch2 <- 3 }() // отправка значения в канал
	val1 := <-ch2            // получение первого значения из канала
	val2 := <-ch2            // получение второго значения из канала
	// Здесь мы создали канал ch размера 2. Мы добавили два значения, а затем получили их одно за другим.
	fmt.Println(val1, val2)
}

// Буферизированные каналы - это каналы, в которых можно хранить не более заданного количества
// сообщений в очереди. Если очередь заполнена, дальнейшая отправка сообщений заблокируется до тех пор,
// пока один или несколько принимающих горутин не получат сообщение из очереди.

// Как результат, основное отличие между буферизированными и не буферизированными каналами
// заключается в том, что в первом случае отправка сообщений может быть продолжена, даже если
// получающая сторона не готова принять сообщение в данный момент времени. Когда очередь заполнена,
// отправка сообщений блокируется до тех пор, пока данные не будут получены из очереди.
