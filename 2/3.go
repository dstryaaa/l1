package main

// Mutex и RWMutex являются механизмами синхронизации доступа к разделяемым ресурсам в Go.
// Оба механизма блокируют доступ к критической секции кода, чтобы избежать гонок данных.

// Однако, RWMutex обеспечивает более гибкую синхронизацию, чем Mutex. Mutex позволяет только одному
// потоку выполнить критическую секцию кода в заданный момент времени, в то время как
// RWMutex позволяет нескольким потокам писать в разделяемый ресурс одновременно, но разрешает
// только одному потоку читать содержимое данного ресурса.

// Использование RWMutex может уменьшить задержку при работе с разделяемыми данными, если чтения
// превалируют над записью. Однако, если запись в разделяемый ресурс является частой операцией,
// то использование RWMutex может привести к снижению производительности.

import (
	"fmt"
	"math/rand"
	"sync"
	"time"
)

var rwm sync.RWMutex
var data map[int]int

func main() {
	data = make(map[int]int)
	// заполняем карту данными
	for i := 0; i < 100; i++ {
		data[i] = i
	}
	// создаем 10 горутин для чтения данных
	for i := 0; i < 2; i++ {
		go readData(i)
	}
	// создаем горутину для записи данных
	go writeData()

	// ждем завершения работы горутин
	time.Sleep(time.Second * 5)
}

func readData(id int) {
	for {
		rwm.RLock()
		fmt.Printf("Горутина %d читает данные\n", id)
		// случайный доступ к данным
		val := data[rand.Intn(100)]
		fmt.Printf("Горутина %d прочитала значение: %d\n", id, val)
		rwm.RUnlock()
		// задержка перед повторным чтением
		time.Sleep(time.Millisecond * 500)
	}
}

func writeData() {
	for {
		rwm.Lock()
		fmt.Println("Горутина для записи данных получила блокировку")
		// случайная запись в данные
		data[rand.Intn(100)] = rand.Intn(100)
		fmt.Println("Горутина для записи данных записала значение")
		rwm.Unlock()
		// задержка перед повторной записью
		time.Sleep(time.Second * 1)
	}
}
